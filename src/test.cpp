//
// Created by 康凯 on 2019-12-19.
//
#include <iostream>
#include <fstream>
#include<sstream>
#include "newickParser.h"
#include "loader.hpp"
#include "simCalc.hpp"
#include <time.h>
using namespace std;
void printHelp(){
    cout<<"--tree(-t) [newick tree path]: path of silva newick tree\n"
    <<"--load_from_list(-ll) + [file list path]: load from list mgnify tsv files\n"
    <<"--load_from_OTU(-lo) + [OTU path]: load from OTU table\n"
    <<"--load_from_package(-lp) + [package path]]: load from package generated by prism2.0\n"
    <<"--matrix(-m) : computing similarity matrix\n"
    <<"--single_search(-ss) + [search sample path] + [select number]: search one sample and return top N (default=5) similar samples\n"
    <<"--multi_search(-ms) + [sample list path] + [select number]: search multi samples and return top N (default=5) similar samples\n"
    <<"--package_search(-ps) + [package path]: search multi samples and return top N (default=5) similar samples\n"
    <<"--OTU_search(-os) + [OTU path]: search multi samples and return top N (default=5) similar samples\n"
    <<"--output(-o) [path]: path to output calculation result\n"
    <<"--save(-s) [path]: save package of loaded file\n"
    <<"--low: low memory mode for matrix result storage, default is on\n"
    // <<"--convertOTU [path]: save as OTU format\n"
    // <<"--outTree [path]: save package of loaded file\n"
    <<"--cores(-c)+ [number of thread]:default single thread\t--help(-h) help\n";
}
int main(int argc, const char * argv[]) {
    // insert code here...
    int i,cores=-1;
    ifstream ifile1,ifile2;ofstream ofile1,ofile2;
    bool helpFlag=false,testFlag=false,lowMemory=true;
    compareResult* result=nullptr;searchResult*result2=nullptr;
    string buffer,pathTree,pathLoad,pathSample,pathOut,pathSave,pathConvert,pathOutTree,pathOutOrder;
    int loadStatus=-1,actionStatus=-1,topN=5,
    outStatus=-1,saveStatus=-1,convertStatus=-1,outTreeStatus=-1,
    outOrderStatus=-1;
    parser *p = nullptr;loader *database,*sample;
    cout << "Welcome to using meta-prism 2.0\n";
    clock_t startTime,finishTime;
    for(i=1;i<argc;i++){
        buffer=argv[i];
        if(buffer=="-t"||buffer=="--tree"){
            pathTree=argv[++i];
        }else if(buffer=="-ll"||buffer=="--load_from_list"){
            if(loadStatus!=-1){
                cout<<"Error, multi load commands\n";
                return 0;
            }else{
                loadStatus=1;
                pathLoad=argv[++i];
            }
        }else if(buffer=="-lp"||buffer=="--load_from_package"){
            if(loadStatus!=-1){
                cout<<"Error, multi load commands\n";
                return 0;
            }else{
                loadStatus=2;
                pathLoad=argv[++i];
            }
        }else if(buffer=="-lo"||buffer=="--load_from_OTU"){
            if(loadStatus!=-1){
                cout<<"Error, multi load commands\n";
                return 0;
            }else{
                loadStatus=3;
                pathLoad=argv[++i];
            }
        }
        else if(buffer=="-m"||buffer=="--matrix"){
            if(actionStatus!=-1){
                cout<<"Error, can't search and calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=1;
            }
        }else if(buffer=="-ss"||buffer=="--single_search"){
            if(actionStatus!=-1){
                cout<<"Error, can't search or calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=2;
                pathSample=argv[++i];
                if(argv[i+1][0]=='-')
                    topN=5;
                else
                    topN=atoi(argv[++i]);
            }
        }else if(buffer=="-ms"||buffer=="--multi_search"){
            if(actionStatus!=-1){
                cout<<"Error, can't search or calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=3;
                pathSample=argv[++i];
                if(argv[i+1][0]=='-')
                    topN=5;
                else
                    topN=atoi(argv[++i]);
            }
        }else if(buffer=="-ps"||buffer=="--package_search"){
            if(actionStatus!=-1){
                cout<<"Error, can't search or calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=4;
                pathSample=argv[++i];
                if(argv[i+1][0]=='-')
                    topN=5;
                else
                    topN=atoi(argv[++i]);
            }
        }else if(buffer=="-os"||buffer=="--OTU_search"){
            if(actionStatus!=-1){
                cout<<"Error, can't search or calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=5;
                pathSample=argv[++i];
                if(argv[i+1][0]=='-')
                    topN=5;
                else
                    topN=atoi(argv[++i]);
            }
        }
        else if(buffer=="-o"||buffer=="--output"){
            if(outStatus!=-1){
                cout<<"Error, can only select path once\n";
                return 0;
            }else{
                outStatus=1;
                pathOut=argv[++i];
            }
        }else if(buffer=="-s"||buffer=="--save"){
            if(saveStatus!=-1){
                cout<<"Error, can only select path once\n";
                return 0;
            }else{
                saveStatus=1;
                pathSave=argv[++i];
            }
        }else if(buffer=="-c"||buffer=="--cores"){
            if(cores!=-1){
                cout<<"Error, can only select cores once\n";
                return 0;
            }else{
                buffer=argv[++i];
                cores=stoi(buffer);
            }
        }else if(buffer=="--convertOTU"){//convert to OTU
            convertStatus=1;
            pathConvert=argv[++i];
        }
        else if(buffer=="--outTree"){
            outTreeStatus=1;
            pathOutTree=argv[++i];
        }
        else if(buffer=="--printOrder"){
            outOrderStatus=1;
            pathOutOrder=argv[++i];
        }
        else if(buffer=="-h"||buffer=="--help")
            helpFlag=true;
        else if(buffer=="--test")
            testFlag=true;
        else if(buffer=="--low"){
            uFP16 d;
            lowMemory=d.check();
            if(!lowMemory)
                cout<<"Compiler or device don't follow IEEE854, can't use low memory mode"<<endl;
        }
        buffer.clear();
    }
    if(i==1 || helpFlag){
        printHelp();
        return 0;
    }
    if(pathTree.length()<2){
        cout<<"Error, not defined newick tree path\n";
        return 0;
    }
    else{
        ifile1.open(pathTree);
        stringstream buf;
        string as,line;
        while(getline(ifile1, line)){
            buf<<line;
        }
        ifile1.close();
        as=buf.str();
        auto b=as.find_first_of('(');
        as=as.substr(b);
        p=new parser(as);
        
    }
    if(loadStatus==-1){
        cout<<"Error, not defined database path\n";
        return 0;
    }else{
        if(testFlag)
            startTime=clock();
        ifile1.open(pathLoad);
        database=new loader(p);
        cout<<"loading from "<<pathLoad<<endl;
        switch (loadStatus) {
            case 1:
                database->loadMultiTSV(ifile1);
                break;
            case 2:
                database->loadFromMirror(ifile1);
                break;
            case 3:
                database->loadOTUData(ifile1);
                break;
            default:
                break;
        }
        ifile1.close();
        if(testFlag){
            finishTime=clock();
            cout<<"load use"<<(double)(finishTime-startTime)/CLOCKS_PER_SEC<<endl;
        }
    }
    if(saveStatus==1){
        ofile1.open(pathSave);
        cout<<"saving data to "<<pathSave<<endl;
        database->outputMirror(ofile1);
        ofile1.close();
    }
    if(actionStatus==-1){
        if(saveStatus==-1&&convertStatus==-1&&outTreeStatus==-1&&outOrderStatus==-1)
        {
            cout<<"Nothing to do\n";
            return 0;
        }
    }else{
        if(actionStatus==1){
            //result=matrixCompare(*database);
            result=matrixBoostCompare(*database,cores,lowMemory);
        }else{
            sample=new loader(p);
            ifile2.open(pathSample);
            switch (actionStatus) {
                case 2:
                    sample->loadTSVFile(ifile2);
                    break;
                case 3:
                    sample->loadMultiTSV(ifile2);
                    break;
                case 4:
                    sample->loadFromMirror(ifile2);
                    break;
                case 5:
                    sample->loadOTUData(ifile2);
                    break;
                default:
                    break;
            }
            ifile2.close();
            //result=searchCompare(*database,  *sample);
            result2 = searchBoostCompare(*database, *sample, cores, topN);
        }
    }
    if(outStatus==1){
        if(testFlag)
            cout<<"skip save step"<<endl;
        else{
            ofile1.open(pathOut);
            if(actionStatus==1){
                if(result==nullptr)
                    cout<<"Error, no result to output\n";
                else{
                    cout<<"Saving calculation result to: "<<pathOut<<endl;
                    result->save(ofile1);}}
            else{
                if(result2==nullptr)
                    cout<<"Error, no result to output\n";
                else{
                    cout<<"Saving calculation result to: "<<pathOut<<endl;
                    sample->genName();
                    database->genName();
                    auto Dnames=database->names;
                    auto Snames=sample->names;
                    for(int i=0;i<sample->size();i++){
                        ofile1<<Snames[i]<<" :";
                        for(int j=0;j<topN;j++){
                            auto name=Dnames[result2->data[i][j].index];
                            ofile1<<' '<<name<<':'<<result2->data[i][j].value;
                            if(j!=topN)
                                ofile1<<',';
                        }
                        ofile1<<endl;
                    }
                }
            }
            ofile1.close();}
    }if(convertStatus==1){
        ofile1.open(pathConvert);
        cout<<"Converting data to: "<<pathConvert<<endl;
        database->printToTable(ofile1);
        ofile1.close();
    }
    if(outTreeStatus==1){
        ofile1.open(pathOutTree);
        p->printTree(ofile1);
        ofile1.close();
    }
    if(outOrderStatus==1){
        ofile1.open(pathOutOrder);
        p->genCompData();
        p->printCompData(ofile1);
        ofile1.close();
    }
    return 0;
}

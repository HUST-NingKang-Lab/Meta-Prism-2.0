//
// Created by 康凯 on 2019-12-19.
//
#include <iostream>
#include <fstream>
#include<sstream>
#include "newickParser.h"
#include "loader.hpp"
#include "simCalc.hpp"
#include <time.h>
using namespace std;
void printHelp(){
    cout<<"--tree(-t) [newick tree path]: path of silva newick tree\n"
    <<"--load_from_list(-ll) + [file list path]: load from list mgnify tsv files\n"
    <<"--load_from_package(-lp) + [package path]]: load from package generated by prism2.0\n"
    <<"--matrix(-m) : computing similarity matrix\n"
    <<"--single_search(-ss) + [search sample path]: search one sample\n"
    <<"--multi_search(-ms) + [sample list path]: search multi samples\n"
    <<"--package_search(-ps) + [package path]: search multi samples\n"
    <<"--output(-o) [path]: path to output calculation result\n"
    <<"--save(-s) [path]: save package of loaded file\n"
    // <<"--convertOTU [path]: save as OTU format\n"
    // <<"--outTree [path]: save package of loaded file\n"
    <<"--cores(-c)+ [cpu core number]:default single core\t--help(-h) help\n";
}
int main(int argc, const char * argv[]) {
    // insert code here...
    int i,cores=-1;
    ifstream ifile1,ifile2;ofstream ofile1,ofile2;
    bool helpFlag=false,testFlag=false;
    compareResult* result;
    string buffer,pathTree,pathLoad,pathSample,pathOut,pathSave,pathConvert,pathOutTree;
    int loadStatus=-1,sampleStatus=-1,actionStatus=-1,
    outStatus=-1,saveStatus=-1,convertStatus=-1,outTreeStatus=-1;
    parser *p = nullptr;loader *database,*sample;
    cout << "Welcome to using meta-prism 2.0\n";
    clock_t startTime,finishTime;
    for(i=1;i<argc;i++){
        buffer=argv[i];
        if(buffer=="-t"||buffer=="--tree"){
            pathTree=argv[++i];
        }else if(buffer=="-ll"||buffer=="--load_from_list"){
            if(loadStatus!=-1){
                cout<<"Error, multi loads\n";
                return 0;
            }else{
                loadStatus=1;
                pathLoad=argv[++i];
            }
        }else if(buffer=="-lp"||buffer=="--load_from_package"){
            if(loadStatus!=-1){
                cout<<"Error, multi loads\n";
                return 0;
            }else{
                loadStatus=2;
                pathLoad=argv[++i];
            }
        }else if(buffer=="-m"||buffer=="--matrix"){
            if(actionStatus!=-1){
                cout<<"Error, can search and calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=1;
            }
        }else if(buffer=="-ss"||buffer=="--single_search"){
            if(actionStatus!=-1){
                cout<<"Error, can search and calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=2;
                pathSample=argv[++i];
            }
        }else if(buffer=="-ms"||buffer=="--multi_search"){
            if(actionStatus!=-1){
                cout<<"Error, can search and calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=3;
                pathSample=argv[++i];
            }
        }else if(buffer=="-ps"||buffer=="--package_search"){
            if(actionStatus!=-1){
                cout<<"Error, can search and calculate matrix in one command\n";
                return 0;
            }else{
                actionStatus=4;
                pathSample=argv[++i];
            }
        }else if(buffer=="-o"||buffer=="--output"){
            if(outStatus!=-1){
                cout<<"Error, can only select path once\n";
                return 0;
            }else{
                outStatus=1;
                pathOut=argv[++i];
            }
        }else if(buffer=="-s"||buffer=="--save"){
            if(saveStatus!=-1){
                cout<<"Error, can only select path once\n";
                return 0;
            }else{
                saveStatus=1;
                pathSave=argv[++i];
            }
        }else if(buffer=="-c"||buffer=="--cores"){
            if(cores!=-1){
                cout<<"Error, can only select cores once\n";
                return 0;
            }else{
                buffer=argv[++i];
                cores=stoi(buffer);
            }
        }else if(buffer=="--convertOTU"){//convert to OTU
            convertStatus=1;
            pathConvert=argv[++i];
        }
        else if(buffer=="--outTree"){
            outTreeStatus=1;
            pathOutTree=argv[++i];
        }
        else if(buffer=="-h"||buffer=="--help")
            helpFlag=true;
        else if(buffer=="--test")
            testFlag=true;
        buffer.clear();
    }
    if(i==1 || helpFlag){
        printHelp();
        return 0;
    }
    if(pathTree.length()<2){
        cout<<"Error, not defined newick tree path\n";
        return 0;
    }
    else{
        ifile1.open(pathTree);
        stringstream buf;
        string as,line;
        while(getline(ifile1, line)){
            buf<<line;
        }
        ifile1.close();
        as=buf.str();
        p=new parser(as);
        
    }
    if(loadStatus==-1){
        cout<<"Error, not defined database path\n";
        return 0;
    }else{
        if(testFlag)
            startTime=clock();
        ifile1.open(pathLoad);
        database=new loader(p);
        cout<<"loading from "<<pathLoad<<endl;
        switch (loadStatus) {
            case 1:
                database->loadMultiTSV(ifile1);
                break;
            case 2:
                database->loadFromMirror(ifile1);
                break;
            default:
                break;
        }
        ifile1.close();
        if(testFlag){
            finishTime=clock();
            cout<<"load use"<<(double)(finishTime-startTime)/CLOCKS_PER_SEC<<endl;
        }
    }
    if(saveStatus==1){
        ofile1.open(pathSave);
        cout<<"saving data to "<<pathSave<<endl;
        database->outputMirror(ofile1);
        ofile1.close();
    }
    if(actionStatus==-1){
        if(saveStatus==-1&&convertStatus==-1&&outTreeStatus==-1)
        {
            cout<<"Nothing to do\n";
            return 0;
        }
    }else{
        if(actionStatus==1){
            //result=matrixCompare(*database);
            result=matrixBoostCompare(*database,cores);
        }else{
            sample=new loader(p);
            ifile2.open(pathSample);
            switch (actionStatus) {
                case 2:
                    sample->loadTSVFile(ifile2);
                    break;
                case 3:
                    sample->loadMultiTSV(ifile2);
                    break;
                case 4:
                    sample->loadFromMirror(ifile2);
                    break;
                default:
                    break;
            }
            ifile2.close();
            result=searchCompare(*database,  *sample);
        }
    }
    if(outStatus==1){
        if(testFlag)
            cout<<"skip save step"<<endl;
        else{
        ofile1.open(pathOut);
        if(result==nullptr)
            cout<<"Error\n";
        else{
            cout<<"Saving calculation result to: "<<pathOut<<endl;
            result->save(ofile1);}
            ofile1.close();}
    }if(convertStatus==1){
        ofile1.open(pathConvert);
            cout<<"Converting data to: "<<pathConvert<<endl;
            database->printToTable(ofile1);
        ofile1.close();
    }
    if(outTreeStatus==1){
        ofile1.open(pathOutTree);
        p->printTree(ofile1);
        ofile1.close();
    }
    return 0;
}
